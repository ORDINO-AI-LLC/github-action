name: 'Ordino Test Runner'
description: 'Run Ordino tests with Cypress or Playwright, with automatic sharding and report upload to Ordino dashboard'
author: 'Ordino'
branding:
  icon: 'check-circle'
  color: 'green'

inputs:
  # Test Framework Selection
  test-framework:
    description: 'Testing framework to use (cypress or playwright)'
    required: true
    default: 'cypress'
  
  # Action Mode
  action-mode:
    description: 'Action mode: test (run tests) or merge-and-upload (merge reports and upload)'
    required: false
    default: 'test'
  
  # Sharding Configuration
  total-shards:
    description: 'Total number of parallel shards'
    required: false
    default: '1'
  
  shard-index:
    description: 'Current shard index (1-based for Playwright compatibility)'
    required: false
    default: '1'
  
  # Commands
  initialize-command:
    description: 'Command to initialize the project'
    required: false
    default: 'npm run initialize'
  
  test-command:
    description: 'Command to run tests (without shard arguments)'
    required: false
    default: 'npm run oi:run:test'
  
  # Configuration
  ordino-url:
    description: 'Ordino API URL'
    required: false
    default: 'https://dev-portal.ordino.ai'
  
  working-directory:
    description: 'Working directory for the tests'
    required: false
    default: '.'
  
  config-file:
    description: 'Cypress configuration file (cypress only)'
    required: false
    default: 'ordino.config.ts'
  
  install-playwright-browsers:
    description: 'Install Playwright browsers'
    required: false
    default: 'true'
  
  # Credentials
  ordino-key:
    description: 'Ordino API key (can also be set via ORDINO_KEY env or .env file)'
    required: false
  
  project-id:
    description: 'Project ID for Ordino (can also be set via PROJECT_ID env or .env file)'
    required: false
  
  use-env-file:
    description: 'Use .env file for credentials if not provided'
    required: false
    default: 'true'
  
  # Control Options
  skip-upload:
    description: 'Skip uploading results to Ordino dashboard'
    required: false
    default: 'false'
  
  continue-on-error:
    description: 'Continue workflow even if tests fail'
    required: false
    default: 'true'
  
  # For merge-and-upload mode
  reports-directory:
    description: 'Directory containing downloaded shard reports (for merge-and-upload mode)'
    required: false
    default: 'all-reports'

outputs:
  test-results-path:
    description: 'Path to test results file'
    value: ${{ steps.prepare-report.outputs.report-path }}
  
  tests-passed:
    description: 'Whether all tests passed'
    value: ${{ steps.run-tests.outputs.tests-passed }}
  
  report-uploaded:
    description: 'Whether the report was successfully uploaded'
    value: ${{ steps.upload-report.outputs.success }}
  
  ordino-dashboard-url:
    description: 'URL to view results in Ordino dashboard'
    value: ${{ steps.upload-report.outputs.dashboard-url }}

runs:
  using: "composite"
  steps:
    # Step 0: Install Required Tools (for Alpine containers)
    - name: Setup Container Environment
      shell: sh
      run: |
        echo "ðŸ”§ Setting up container environment..."
        
        # Detect if we're in Alpine Linux
        if [ -f /etc/alpine-release ]; then
          echo "Detected Alpine Linux container"
          if ! command -v bash >/dev/null 2>&1; then
            echo "Installing bash..."
            apk add --no-cache bash
          fi
          if ! command -v curl >/dev/null 2>&1; then
            echo "Installing curl..."
            apk add --no-cache curl
          fi
          if ! command -v node >/dev/null 2>&1; then
            echo "Installing Node.js..."
            apk add --no-cache nodejs npm
          fi
        fi
        
        # Detect if we're in Debian/Ubuntu
        if [ -f /etc/debian_version ]; then
          echo "Detected Debian/Ubuntu container"
          if ! command -v curl >/dev/null 2>&1; then
            echo "Installing curl..."
            apt-get update && apt-get install -y curl
          fi
        fi
    
    # Step 1: Setup Environment
    - name: Setup Environment
      id: setup
      shell: bash
      run: |
        echo "ðŸš€ Setting up Ordino Test Runner"
        echo "Mode: ${{ inputs.action-mode }}"
        echo "Framework: ${{ inputs.test-framework }}"
        echo "Total Shards: ${{ inputs.total-shards }}"
        echo "Current Shard: ${{ inputs.shard-index }}"
        echo "Working Directory: ${{ inputs.working-directory }}"
        
        # Validate framework selection
        if [[ "${{ inputs.test-framework }}" != "cypress" && "${{ inputs.test-framework }}" != "playwright" ]]; then
          echo "âŒ Error: test-framework must be either 'cypress' or 'playwright'"
          exit 1
        fi
    
    # Step 2: Load Credentials
    - name: Load Credentials
      id: load-credentials
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Priority: Input parameters > Environment variables > .env file
        ORDINO_KEY="${{ inputs.ordino-key }}"
        PROJECT_ID="${{ inputs.project-id }}"
        
        # Try environment variables if inputs are empty
        if [ -z "$ORDINO_KEY" ]; then
          ORDINO_KEY="${ORDINO_KEY:-${{ env.ORDINO_KEY }}}"
        fi
        if [ -z "$PROJECT_ID" ]; then
          PROJECT_ID="${PROJECT_ID:-${{ env.PROJECT_ID }}}"
        fi
        
        # Try .env file if still empty and use-env-file is true
        if [[ "${{ inputs.use-env-file }}" == "true" ]] && [[ -z "$ORDINO_KEY" || -z "$PROJECT_ID" ]]; then
          if [ -f ".env" ]; then
            echo "ðŸ“ Loading credentials from .env file..."
            set -a
            source .env
            set +a
          elif [ -f "/root/.env" ]; then
            echo "ðŸ“ Loading credentials from /root/.env file..."
            set -a
            source /root/.env
            set +a
          fi
        fi
        
        # Mask and output credentials
        if [ -n "$ORDINO_KEY" ]; then
          echo "::add-mask::$ORDINO_KEY"
          echo "ordino-key=$ORDINO_KEY" >> $GITHUB_OUTPUT
          echo "âœ… ORDINO_KEY loaded"
        else
          echo "âš ï¸ Warning: ORDINO_KEY not found"
        fi
        
        if [ -n "$PROJECT_ID" ]; then
          echo "::add-mask::$PROJECT_ID"
          echo "project-id=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "âœ… PROJECT_ID loaded"
        else
          echo "âš ï¸ Warning: PROJECT_ID not found"
        fi
        
        # Only fail if we're not skipping upload
        if [[ "${{ inputs.skip-upload }}" == "false" ]] && [[ -z "$ORDINO_KEY" || -z "$PROJECT_ID" ]]; then
          echo "âŒ Error: ORDINO_KEY and PROJECT_ID are required for uploading results"
          exit 1
        fi
    
    # Step 3: Cache Dependencies (only for test mode)
    - name: Cache Dependencies
      if: ${{ inputs.action-mode == 'test' }}
      uses: actions/cache@v4
      with:
        path: |
          ~/.npm
          ~/.cache
          ${{ inputs.working-directory }}/node_modules
        key: ordino-${{ inputs.test-framework }}-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ordino-${{ inputs.test-framework }}-${{ runner.os }}-
    
    # Step 4: Install Dependencies (only for test mode)
    - name: Install Dependencies
      if: ${{ inputs.action-mode == 'test' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        ORDINO_KEY: ${{ steps.load-credentials.outputs.ordino-key }}
      run: |
        echo "ðŸ“¦ Installing dependencies..."
        
        # Try the initialize command
        if ! ${{ inputs.initialize-command }} --legacy-peer-deps --omit=optional; then
          echo "Initialize command failed, trying without flags..."
          ${{ inputs.initialize-command }}
        fi
        
        # Install Playwright browsers if needed
        if [[ "${{ inputs.test-framework }}" == "playwright" ]] && [[ "${{ inputs.install-playwright-browsers }}" == "true" ]]; then
          echo "ðŸŽ­ Installing Playwright browsers..."
          if [ -f /etc/alpine-release ]; then
            echo "âš ï¸ Warning: Alpine Linux detected. Installing additional dependencies..."
            apk add --no-cache chromium nss freetype freetype-dev harfbuzz ca-certificates ttf-freefont
          fi
          
          if command -v npx &> /dev/null; then
            npx playwright install chromium || true
            npx playwright install-deps chromium || true
          fi
        fi
    
    # Step 5: Run Tests (only for test mode - WITH SHARDING SUPPORT)
    - name: Run Tests
      id: run-tests
      if: ${{ inputs.action-mode == 'test' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        ORDINO_KEY: ${{ steps.load-credentials.outputs.ordino-key }}
        TEST_FRAMEWORK: ${{ inputs.test-framework }}
      run: |
        echo "ðŸ§ª Running ${{ inputs.test-framework }} tests..."
        
        # Create report directory
        mkdir -p ordino-report
        
        # Set test exit code variable
        TEST_EXIT_CODE=0
        
        # Run tests based on framework
        if [[ "${{ inputs.test-framework }}" == "cypress" ]]; then
          echo "Running Cypress tests..."
          mkdir -p ordino-report/report
          
          # Run with Cypress sharding if needed
          if [[ "${{ inputs.total-shards }}" -gt "1" ]]; then
            CYPRESS_SHARD_INDEX=$((${{ inputs.shard-index }} - 1))
            export SPLIT="${{ inputs.total-shards }}"
            export SPLIT_INDEX="$CYPRESS_SHARD_INDEX"
            echo "Running with SPLIT=$SPLIT SPLIT_INDEX=$SPLIT_INDEX"
          fi
          
          if ${{ inputs.test-command }}; then
            echo "âœ… Tests completed successfully"
          else
            TEST_EXIT_CODE=$?
            echo "âš ï¸ Tests completed with exit code: $TEST_EXIT_CODE"
          fi
        else
          echo "Running Playwright tests..."
          
          # Run with Playwright sharding if needed
          if [[ "${{ inputs.total-shards }}" -gt "1" ]]; then
            echo "Running shard ${{ inputs.shard-index }} of ${{ inputs.total-shards }}"
            TEST_CMD="${{ inputs.test-command }} -- --shard=${{ inputs.shard-index }}/${{ inputs.total-shards }}"
            echo "Running command: $TEST_CMD"
            
            if eval "$TEST_CMD"; then
              echo "âœ… Tests completed successfully"
            else
              TEST_EXIT_CODE=$?
              echo "âš ï¸ Tests completed with exit code: $TEST_EXIT_CODE"
            fi
          else
            # No sharding
            if ${{ inputs.test-command }}; then
              echo "âœ… Tests completed successfully"
            else
              TEST_EXIT_CODE=$?
              echo "âš ï¸ Tests completed with exit code: $TEST_EXIT_CODE"
            fi
          fi
          
          # Verify test-results-final.json exists
          if [ -f "test-results-final.json" ]; then
            echo "âœ… Found test-results-final.json in root"
          else
            echo "âš ï¸ Warning: test-results-final.json not found in root"
          fi
        fi
        
        # Set output based on test results
        if [ $TEST_EXIT_CODE -eq 0 ]; then
          echo "tests-passed=true" >> $GITHUB_OUTPUT
        else
          echo "tests-passed=false" >> $GITHUB_OUTPUT
          if [[ "${{ inputs.continue-on-error }}" == "false" ]]; then
            exit $TEST_EXIT_CODE
          fi
        fi
    
    # Step 6: Merge Reports (for merge-and-upload mode - HANDLES PLAYWRIGHT MERGE)
    - name: Merge Parallel Reports
      id: merge-reports
      if: ${{ inputs.action-mode == 'merge-and-upload' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ“Š Merging reports from parallel execution..."
        
        if [[ "${{ inputs.test-framework }}" == "cypress" ]]; then
          # Cypress: Use mochawesome-merge
          echo "Merging Cypress reports..."
          mkdir -p ordino-report/report
          
          # Copy all Cypress reports from downloaded artifacts
          for report_dir in ${{ inputs.reports-directory }}/*/; do
            if [ -d "$report_dir/report" ]; then
              cp "$report_dir"/report/*.json ordino-report/report/ 2>/dev/null || true
            fi
          done
          
          # Merge using mochawesome-merge
          if ls ordino-report/report/*.json 1> /dev/null 2>&1; then
            npx mochawesome-merge "ordino-report/report/*.json" > ordino-report/final-report.json
            echo "âœ… Successfully merged Cypress reports"
            echo "report-path=ordino-report/final-report.json" >> $GITHUB_OUTPUT
          else
            echo "âŒ No Cypress reports found to merge"
            exit 1
          fi
        else
          # Playwright: Use merge-report.js to merge test-results-final.json files
          echo "Merging Playwright reports using merge-report.js..."
          mkdir -p ordino-report
          
          # Find and copy all test-results-final.json files from shards
          shard_count=0
          
          # Look for test-results-final.json in the reports directory structure
          for final_json in $(find ${{ inputs.reports-directory }} -name "test-results-final.json" -type f); do
            shard_count=$((shard_count + 1))
            # Copy to ordino-report directory with shard naming
            cp "$final_json" "ordino-report/test-results-final-shard-$shard_count.json"
            echo "âœ… Copied test-results-final.json from shard $shard_count"
          done
          
          if [ $shard_count -gt 0 ]; then
            echo "ðŸ”„ Using merge-reports.js to merge $shard_count shard reports..."
            
            # Check if merge-reports.js exists
            if [ -f "merge-reports.js" ]; then
              # Run merge-reports.js with input directory and output file
              echo "Running: node merge-reports.js ordino-report test-results-final.json"
              node merge-reports.js ordino-report test-results-final.json
              
              # Check if merged report was created
              if [ -f "test-results-final.json" ]; then
                echo "âœ… Successfully merged $shard_count reports into test-results-final.json"
                echo "report-path=test-results-final.json" >> $GITHUB_OUTPUT
              else
                echo "âŒ Failed to create merged test-results-final.json"
                exit 1
              fi
            else
              echo "âŒ Error: merge-reports.js not found in repository root!"
              echo "Please ensure merge-reports.js exists in your repository"
              exit 1
            fi
          else
            echo "âŒ No test-results-final.json files found for merge"
            exit 1
          fi
        fi
    
    # Step 7: Prepare Report (for single execution only)
    - name: Prepare Test Report
      id: prepare-report
      if: ${{ inputs.action-mode == 'test' && inputs.total-shards == '1' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ“Š Preparing test report for single execution..."
        
        if [[ "${{ inputs.test-framework }}" == "cypress" ]]; then
          # Cypress report handling
          if ls ordino-report/report/*.json 1> /dev/null 2>&1; then
            if command -v npx &> /dev/null; then
              npx mochawesome-merge "ordino-report/report/*.json" > ordino-report/final-report.json || {
                echo "Failed to merge, using first report..."
                cp ordino-report/report/*.json ordino-report/final-report.json
              }
            else
              cp ordino-report/report/*.json ordino-report/final-report.json
            fi
            echo "report-path=ordino-report/final-report.json" >> $GITHUB_OUTPUT
          else
            echo "No Cypress reports found"
            echo "report-path=" >> $GITHUB_OUTPUT
          fi
        else
          # Playwright report handling - use test-results-final.json from root
          if [ -f "test-results-final.json" ]; then
            echo "âœ… Found test-results-final.json in root"
            echo "report-path=test-results-final.json" >> $GITHUB_OUTPUT
          else
            echo "âŒ No test-results-final.json found in root"
            echo "report-path=" >> $GITHUB_OUTPUT
          fi
        fi
    
    # Step 8: Upload Report to Ordino (UNIFIED FOR ALL SCENARIOS)
    - name: Upload Report to Ordino
      id: upload-report
      if: ${{ inputs.skip-upload == 'false' && (inputs.action-mode == 'merge-and-upload' || inputs.total-shards == '1') }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "â˜ï¸ Uploading report to Ordino dashboard..."
        
        API_URL="${{ inputs.ordino-url }}/api/v1/test-report-external"
        BUILD_ID="${GITHUB_RUN_ID}"
        PROJECT_ID="${{ steps.load-credentials.outputs.project-id }}"
        API_KEY="${{ steps.load-credentials.outputs.ordino-key }}"
        
        # Determine which report to upload
        if [[ "${{ inputs.action-mode }}" == "merge-and-upload" ]]; then
          REPORT_PATH="${{ steps.merge-reports.outputs.report-path }}"
        else
          REPORT_PATH="${{ steps.prepare-report.outputs.report-path }}"
        fi
        
        if [ -z "$REPORT_PATH" ] || [ ! -f "$REPORT_PATH" ]; then
          echo "âŒ Error: No report file found to upload"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "Uploading report from: $REPORT_PATH"
        echo "File size: $(wc -c < "$REPORT_PATH") bytes"
        
        # Upload the report
        response=$(curl --location "$API_URL" \
          --header "Ordino-Key: $API_KEY" \
          --form "file=@$REPORT_PATH" \
          --form "ProjectId=$PROJECT_ID" \
          --form "ExecutionId=$BUILD_ID" \
          --write-out "%{http_code}" \
          --silent \
          --output response.json)
        
        if [ "$response" -eq 200 ] || [ "$response" -eq 201 ]; then
          echo "âœ… Report uploaded successfully!"
          echo "success=true" >> $GITHUB_OUTPUT
          echo "dashboard-url=${{ inputs.ordino-url }}/dashboard/project/$PROJECT_ID/execution/$BUILD_ID" >> $GITHUB_OUTPUT
        else
          echo "âŒ Failed to upload report. HTTP status: $response"
          if [ -f response.json ]; then
            cat response.json
          fi
          echo "success=false" >> $GITHUB_OUTPUT
          if [[ "${{ inputs.continue-on-error }}" == "false" ]]; then
            exit 1
          fi
        fi
    
    # Step 9: Upload Trace Files (for Playwright only)
    - name: Upload Playwright Trace Files
      id: upload-traces
      if: ${{ inputs.test-framework == 'playwright' && inputs.skip-upload == 'false' && (inputs.action-mode == 'merge-and-upload' || inputs.total-shards == '1') }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "ðŸ“¤ Checking for Playwright trace files and screenshots..."
        
        # Create temporary directory for collecting traces
        TEMP_TRACE_DIR="temp-traces-collection"
        mkdir -p "$TEMP_TRACE_DIR"
        
        if [[ "${{ inputs.action-mode }}" == "merge-and-upload" ]]; then
          echo "ðŸ” Collecting trace files and screenshots from all shards..."
          
          # For merge mode, search in the reports directory from all shards
          SEARCH_DIR="${{ inputs.reports-directory }}"
          
          if [ ! -d "$SEARCH_DIR" ]; then
            echo "âš ï¸ Reports directory not found: $SEARCH_DIR"
            echo "Skipping trace upload"
            exit 0
          fi
          
          # Find all trace-report directories, excluding retry folders
          TRACE_DIRS=$(find "$SEARCH_DIR" -type d -name "trace-report" 2>/dev/null || true)
          
          if [ -z "$TRACE_DIRS" ]; then
            echo "âš ï¸ No trace-report directories found"
            echo "Skipping trace upload"
            exit 0
          fi
          
          TRACE_COUNT=0
          
          # Process each trace-report directory
          while IFS= read -r trace_dir; do
            echo "Processing: $trace_dir"
            
            # Find all subdirectories in trace-report (each test folder)
            find "$trace_dir" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | while read -r test_folder; do
              # Get the folder name
              TEST_FOLDER_NAME=$(basename "$test_folder")
              
              # Check if this is a retry folder
              if echo "$TEST_FOLDER_NAME" | grep -qE '(-retry-[0-9]+|retry[0-9]+)'; then
                echo "  â­ï¸  Skipping retry folder: $TEST_FOLDER_NAME"
                continue
              fi
              
              # This is a valid test folder, collect all files
              TRACE_COUNT=$((TRACE_COUNT + 1))
              
              # Create a subdirectory for this test in temp collection
              mkdir -p "$TEMP_TRACE_DIR/test-${TRACE_COUNT}-${TEST_FOLDER_NAME}"
              
              # Copy trace.zip if exists
              if [ -f "$test_folder/trace.zip" ]; then
                cp "$test_folder/trace.zip" "$TEMP_TRACE_DIR/test-${TRACE_COUNT}-${TEST_FOLDER_NAME}/trace.zip"
                echo "  âœ… Collected trace.zip from: $TEST_FOLDER_NAME"
              fi
              
              # Copy all .png files (screenshots)
              PNG_FILES=$(find "$test_folder" -maxdepth 1 -name "*.png" -type f 2>/dev/null || true)
              if [ -n "$PNG_FILES" ]; then
                while IFS= read -r png_file; do
                  PNG_NAME=$(basename "$png_file")
                  cp "$png_file" "$TEMP_TRACE_DIR/test-${TRACE_COUNT}-${TEST_FOLDER_NAME}/$PNG_NAME"
                  echo "  âœ… Collected screenshot: $PNG_NAME from $TEST_FOLDER_NAME"
                done <<< "$PNG_FILES"
              fi
            done
          done <<< "$TRACE_DIRS"
          
          # Count collected test folders
          COLLECTED_COUNT=$(find "$TEMP_TRACE_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
          
          if [ "$COLLECTED_COUNT" -eq 0 ]; then
            echo "âš ï¸ No trace files collected after filtering retries"
            echo "Skipping trace upload"
            rm -rf "$TEMP_TRACE_DIR"
            exit 0
          fi
          
          echo "âœ… Collected traces and screenshots from $COLLECTED_COUNT tests (excluding retries)"
          
        else
          echo "ðŸ” Collecting trace files and screenshots from single execution..."
          
          # For single execution, look in test-results or playwright-report
          TRACE_DIR="trace-report"
          if [ ! -d "$TRACE_DIR" ]; then
            TRACE_DIR="test-results"
          fi
          if [ ! -d "$TRACE_DIR" ]; then
            TRACE_DIR="playwright-report"
          fi
          
          if [ ! -d "$TRACE_DIR" ]; then
            echo "âš ï¸ No trace directory found"
            echo "Skipping trace upload"
            rm -rf "$TEMP_TRACE_DIR"
            exit 0
          fi
          
          TRACE_COUNT=0
          
          # Find all subdirectories in trace directory (each test folder)
          find "$TRACE_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | while read -r test_folder; do
            # Get the folder name
            TEST_FOLDER_NAME=$(basename "$test_folder")
            
            # Check if this is a retry folder
            if echo "$TEST_FOLDER_NAME" | grep -qE '(-retry-[0-9]+|retry[0-9]+)'; then
              echo "  â­ï¸  Skipping retry folder: $TEST_FOLDER_NAME"
              continue
            fi
            
            # This is a valid test folder, collect all files
            TRACE_COUNT=$((TRACE_COUNT + 1))
            
            # Create a subdirectory for this test in temp collection
            mkdir -p "$TEMP_TRACE_DIR/test-${TRACE_COUNT}-${TEST_FOLDER_NAME}"
            
            # Copy trace.zip if exists
            if [ -f "$test_folder/trace.zip" ]; then
              cp "$test_folder/trace.zip" "$TEMP_TRACE_DIR/test-${TRACE_COUNT}-${TEST_FOLDER_NAME}/trace.zip"
              echo "  âœ… Collected trace.zip from: $TEST_FOLDER_NAME"
            fi
            
            # Copy all .png files (screenshots)
            PNG_FILES=$(find "$test_folder" -maxdepth 1 -name "*.png" -type f 2>/dev/null || true)
            if [ -n "$PNG_FILES" ]; then
              while IFS= read -r png_file; do
                PNG_NAME=$(basename "$png_file")
                cp "$png_file" "$TEMP_TRACE_DIR/test-${TRACE_COUNT}-${TEST_FOLDER_NAME}/$PNG_NAME"
                echo "  âœ… Collected screenshot: $PNG_NAME from $TEST_FOLDER_NAME"
              done <<< "$PNG_FILES"
            fi
          done
          
          # Count collected test folders
          COLLECTED_COUNT=$(find "$TEMP_TRACE_DIR" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
          
          if [ "$COLLECTED_COUNT" -eq 0 ]; then
            echo "âš ï¸ No trace files found after filtering retries"
            echo "Skipping trace upload"
            rm -rf "$TEMP_TRACE_DIR"
            exit 0
          fi
          
          echo "âœ… Collected traces and screenshots from $COLLECTED_COUNT tests (excluding retries)"
        fi
        
        # Create single zip file from all collected traces and screenshots
        echo "ðŸ“¦ Creating consolidated all-traces.zip..."
        cd "$TEMP_TRACE_DIR"
        zip -r ../all-traces.zip . -q
        cd ..
        
        UPLOAD_FILE="all-traces.zip"
        FILE_SIZE=$(du -h "$UPLOAD_FILE" | cut -f1)
        echo "âœ… Created $UPLOAD_FILE (Size: $FILE_SIZE)"
        
        # List contents for verification
        echo "ðŸ“‹ Archive contents:"
        unzip -l "$UPLOAD_FILE" | head -20
        
        # Step 1: Get presigned URL
        echo "ðŸ”— Getting presigned URL for trace upload..."
        
        PRESIGNED_API_URL="${{ inputs.ordino-url }}/api/v1/test-report-external/trace-log/presigned-url"
        PROJECT_ID="${{ steps.load-credentials.outputs.project-id }}"
        API_KEY="${{ steps.load-credentials.outputs.ordino-key }}"
        BUILD_ID="${GITHUB_RUN_ID}"
        
        echo "API URL: $PRESIGNED_API_URL"
        echo "Project ID: $PROJECT_ID"
        echo "Build ID: $BUILD_ID"
        
        # Request presigned URL
        PRESIGNED_RESPONSE=$(curl --location "$PRESIGNED_API_URL" \
          --header "Ordino-Key: $API_KEY" \
          --header "Content-Type: application/json" \
          --data '{
            "projectId": "'$PROJECT_ID'",
            "executionId": "'$BUILD_ID'"
          }' \
          --silent)
        
        # Extract presigned URL and test report ID
        PRESIGNED_URL=$(echo "$PRESIGNED_RESPONSE" | grep -o '"PresignedUrl":"[^"]*' | cut -d'"' -f4)
        TEST_REPORT_ID=$(echo "$PRESIGNED_RESPONSE" | grep -o '"TestReportId":"[^"]*' | cut -d'"' -f4)
        
        if [ -z "$PRESIGNED_URL" ] || [ -z "$TEST_REPORT_ID" ]; then
          echo "âŒ Failed to get presigned URL"
          echo "Response: $PRESIGNED_RESPONSE"
          echo "âš ï¸ Trace upload failed, but continuing workflow..."
          rm -rf "$TEMP_TRACE_DIR" "$UPLOAD_FILE"
          exit 0
        fi
        
        echo "âœ… Got presigned URL and TestReportId: $TEST_REPORT_ID"
        # Step 2: Upload trace file to presigned URL
        echo "â˜ï¸ Uploading consolidated traces and screenshots to Ordino..."
        echo "Upload file: $UPLOAD_FILE"
        echo "File size: $(du -h "$UPLOAD_FILE" | cut -f1)"
        echo "Presigned URL (first 100 chars): ${PRESIGNED_URL:0:100}..."
        
        UPLOAD_RESPONSE=$(curl --location "$PRESIGNED_URL" \
          --request PUT \
          --header "Content-Type: application/zip" \
          --data-binary "@$UPLOAD_FILE" \
          --write-out "\n{\"http_code\":\"%{http_code}\",\"size_upload\":\"%{size_upload}\",\"speed_upload\":\"%{speed_upload}\",\"time_total\":\"%{time_total}\"}" \
          --silent \
          --show-error \
          --output upload-response.txt 2>&1)
        
        echo "Upload Response Details:"
        echo "$UPLOAD_RESPONSE"
        
        # Extract HTTP code from the response
        HTTP_UPLOAD_CODE=$(echo "$UPLOAD_RESPONSE" | grep -o '"http_code":"[^"]*' | cut -d'"' -f4)
        
        echo "HTTP Upload Status Code: $HTTP_UPLOAD_CODE"
        
        if [ -f upload-response.txt ]; then
          echo "Upload response body:"
          cat upload-response.txt
          rm -f upload-response.txt
        fi
        
        # Step 3: Update status
        STATUS_API_URL="${{ inputs.ordino-url }}/api/v1/test-report-external/trace-log/status"
        
        # FIX: Use HTTP_UPLOAD_CODE instead of UPLOAD_RESPONSE
        if [ "$HTTP_UPLOAD_CODE" = "200" ] || [ "$HTTP_UPLOAD_CODE" = "201" ]; then
          echo "âœ… Trace file uploaded successfully (HTTP $HTTP_UPLOAD_CODE)"
          COMPLETED="true"
        else
          echo "âŒ Failed to upload trace file. HTTP status: $HTTP_UPLOAD_CODE"
          COMPLETED="false"
        fi
        
        # Send status update
        echo "ðŸ“Š Updating trace upload status..."
        
        STATUS_RESPONSE=$(curl --location "$STATUS_API_URL" \
          --request PUT \
          --header "Ordino-Key: $API_KEY" \
          --header "Content-Type: application/json" \
          --data '{
            "TestReportId": "'$TEST_REPORT_ID'",
            "Completed": '$COMPLETED'
          }' \
          --silent)
        
        # Check if status update was successful
        IS_SUCCESS=$(echo "$STATUS_RESPONSE" | grep -o '"IsSuccess":true' || true)
        
        if [ -n "$IS_SUCCESS" ]; then
          echo "âœ… Trace upload status updated successfully"
          echo "trace-upload-success=true" >> $GITHUB_OUTPUT
        else
          echo "âš ï¸ Failed to update trace upload status"
          echo "Response: $STATUS_RESPONSE"
          echo "trace-upload-success=false" >> $GITHUB_OUTPUT
        fi
        
        # Clean up temporary files
        echo "ðŸ§¹ Cleaning up temporary files..."
        rm -rf "$TEMP_TRACE_DIR" "$UPLOAD_FILE"
        
        echo "âœ¨ Trace upload process completed!"
    
    # Step 10: Summary
    - name: Generate Summary
      if: always()
      shell: bash
      run: |
        echo "## ðŸ“Š Ordino Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Mode**: ${{ inputs.action-mode }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Framework**: ${{ inputs.test-framework }}" >> $GITHUB_STEP_SUMMARY
        if [[ "${{ inputs.action-mode }}" == "test" ]]; then
          if [[ "${{ inputs.total-shards }}" -gt "1" ]]; then
            echo "- **Shard**: ${{ inputs.shard-index }} of ${{ inputs.total-shards }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- **Tests Passed**: ${{ steps.run-tests.outputs.tests-passed }}" >> $GITHUB_STEP_SUMMARY
        fi
        if [[ "${{ steps.upload-report.outputs.success }}" != "" ]]; then
          echo "- **Report Uploaded**: ${{ steps.upload-report.outputs.success }}" >> $GITHUB_STEP_SUMMARY
        fi
